package at.ac.tuwien.infosys.www.pixy;

import at.ac.tuwien.infosys.www.pixy.analysis.dependency.DependencyAnalysis;
import at.ac.tuwien.infosys.www.pixy.analysis.dependency.Sink;
import at.ac.tuwien.infosys.www.pixy.analysis.dependency.graph.*;
import at.ac.tuwien.infosys.www.pixy.conversion.*;
import at.ac.tuwien.infosys.www.pixy.conversion.cfgnodes.AbstractCfgNode;
import at.ac.tuwien.infosys.www.pixy.conversion.cfgnodes.CallUnknownFunction;

import java.util.*;

/**
 * If you want to create a new vulnerability analysis:
 * 1. inherit from this class (see existing examples)
 * 2. add info to MyOptions.analyses
 * 3. add model and sink config files
 *
 * @author Nenad Jovanovic <enji@seclab.tuwien.ac.at>
 */
public abstract class AbstractVulnerabilityAnalysis {
    protected DependencyAnalysis dependencyAnalysis;
    protected VulnerabilityAnalysisInformation vulnerabilityAnalysisInformation;

    /**
     * Flags returned by getInitialTaintForPlace():
     * - always tainted
     * - tainted if register_globals is active
     */
    public enum InitialTaint {ALWAYS, IF_REGISTER_GLOBALS, NEVER}

    /**
     * Should members of the $_GET array be considered as initially tainted? Defaults to true, of course.
     */
    protected boolean getIsTainted = true;

    protected AbstractVulnerabilityAnalysis(DependencyAnalysis dependencyAnalysis) {
        this.dependencyAnalysis = dependencyAnalysis;
        this.vulnerabilityAnalysisInformation = MyOptions.getVulnerabilityAnalysisInformation(this.getClass().getName());
    }

    /**
     * Detects vulnerabilities and returns a list with the line numbers of the detected vulnerabilities.
     *
     * @return the line numbers of the detected vulnerabilities
     */
    public abstract List<Integer> detectVulnerabilities();

    public abstract VulnerabilityInformation detectAlternative();

    /**
     * Checks if the given node (inside the given function) is a sensitive sink.
     *
     * Adds an appropriate sink object to the given list if it is a sink.
     *
     * @param cfgNodeX
     * @param traversedFunction
     * @param sinks
     */
    protected abstract void checkForSink(AbstractCfgNode cfgNodeX, TacFunction traversedFunction, List<Sink> sinks);

    /**
     * Returns a list of sinks for this analysis.
     *
     * @return
     */
    public List<Sink> collectSinks() {
        List<Sink> sinks = new LinkedList<>();
        for (TacFunction function : this.dependencyAnalysis.getFunctions()) {
            for (AbstractCfgNode cfgNode : function.getControlFlowGraph().dfPreOrder()) {
                checkForSink(cfgNode, function, sinks);
            }
        }
        return sinks;
    }

    protected boolean isStrongSanitation(String opName) {
        return this.vulnerabilityAnalysisInformation.getFunctionModels().getF_strongSanit().contains(opName);
    }

    protected boolean isWeakSanitation(String opName, List<Integer> indices) {
        Set<Integer> i = this.vulnerabilityAnalysisInformation.getFunctionModels().getF_weakSanit().get(opName);
        if (i == null) {
            return false;
        }

        indices.addAll(i);
        return true;
    }

    protected boolean isEvil(String opName) {
        return this.vulnerabilityAnalysisInformation.getFunctionModels().getF_evil().contains(opName);
    }

    /**
     * If the given operation is a multi-dependency operation, it returns true and fills the given indices list with the
     * appropriate index numbers.
     *
     * @param operationName
     * @param indices
     *
     * @return
     */
    protected boolean isMultiDependencyOperation(String operationName, List<Integer> indices) {
        Set<Integer> i = this.vulnerabilityAnalysisInformation.getFunctionModels().getF_multi().get(operationName);
        if (i == null) {
            return false;
        }
        indices.addAll(i);

        return true;
    }

    /**
     * Analogous to isMultiDependencyOperation, but inverse: e.g., if some function is an inverse
     * multi-dependency with a returned index "2", then all its parameters are relevant, except for parameter #2.
     *
     * @param operationName
     * @param indices
     * @return
     */
    protected boolean isInverseMultiDependencyOperation(String operationName, List<Integer> indices) {
        Set<Integer> i = this.vulnerabilityAnalysisInformation.getFunctionModels().getF_invMulti().get(operationName);
        if (i == null) {
            return false;
        }
        indices.addAll(i);
        return true;
    }

    protected InitialTaint getInitialTaintForPlace(AbstractTacPlace place) {
        InitialTaint initialTaint;

        if (place instanceof Variable) {
            initialTaint = getInitialTaintValueForVariable((Variable) place);
        } else if (place instanceof Constant) {
            initialTaint = getInitialTaintForConstant();
        } else {
            // Have we missed something? Everything else is tainted.
            initialTaint = InitialTaint.ALWAYS;
        }

        return initialTaint;
    }

    private InitialTaint getInitialTaintValueForVariable(Variable variable) {
        InitialTaint initialTaint;

        if (variable.isSuperGlobal()) {
            initialTaint = getInitialTaintForSuperGobal(variable);
        } else {
            initialTaint = getInitialTaintForNonSuperGlobal(variable);
        }

        return initialTaint;
    }

    private InitialTaint getInitialTaintForSuperGobal(Variable variable) {
        String variableName = variable.getName();
        // return variables
        if (variable.isReturnVariable()) {
            return InitialTaint.NEVER;
        } else if (MyOptions.isHarmlessServerVar(variableName) ||
            variableName.equals("$_SERVER")) {
            // harmless member of the SERVER array,
            // or the SERVER array itself
            return InitialTaint.NEVER;
        } else if (variableName.startsWith("$_SESSION[")) {
            // the whole session array
            return InitialTaint.NEVER;
        } else if (variableName.equals("$_ENV") ||
            variableName.equals("$_HTTP_ENV_VARS") ||
            variableName.startsWith("$_ENV[") ||
            variableName.startsWith("$HTTP_ENV_VARS[")) {
            // the whole env array
            return InitialTaint.NEVER;
        } else if (!this.getIsTainted && variableName.startsWith("$_GET[")) {
            // the whole GET array, if it shall be considered
            // as not tainted
            return InitialTaint.NEVER;
        } else {
            // non-harmless superglobal
            return InitialTaint.ALWAYS;
        }
    }

    private InitialTaint getInitialTaintForNonSuperGlobal(Variable variable) {
        String variableName = variable.getName();
        if (variable.getSymbolTable().getName().equals("_special")) {
            if (variableName.equals(InternalStrings.memberName)) {
                return InitialTaint.NEVER;
            }

            throw new RuntimeException("This is not supposed to happen.");
        } else if (variableName.equals("$PHPSESSID")) {
            // the special php session id variable is harmless
            return InitialTaint.NEVER;
        } else if (MyOptions.harmlessServerIndices.contains(variableName.substring(1))) {
            // something like $SERVER_NAME etc.
            // (i.e. harmless indices of the SERVER array that have been
            // exported into main's scope due to register_globals
            return InitialTaint.NEVER;
        } else if (!variable.getSymbolTable().isMain()) {
            // local function variables are untainted
            return InitialTaint.NEVER;
        } else {
            // a global variable
            if (!MyOptions.optionG) {
                // if the user decided to disable register_globals,
                // ignore these cases
                return InitialTaint.NEVER;
            } else {
                return InitialTaint.IF_REGISTER_GLOBALS;
            }
        }
    }

    /**
     * gets the initial taint value for constants.
     *
     * @return always untainted
     */
    private InitialTaint getInitialTaintForConstant() {
        return InitialTaint.NEVER;
    }

    /**
     * Extracts the "relevant subgraph", using models for builtin functions.
     *
     * Here is how it works:
     *
     * - for operation nodes representing sanitization functions, the top-down algorithm
     * doesn't follow its successors; instead, a single new successor ("<sanitation>")
     * is created
     * - evil functions: a single <uninit> successor is created
     * - multi-dependency: the algorithm only follows those successors that are defined as relevant for XSS
     * - unmodeled functions are treated as if they were evil functions
     *
     * @param dependencyGraph
     *
     * @return
     */
    protected DependencyGraph getRelevantSubgraph(DependencyGraph dependencyGraph) {
        // start with a one-element graph
        DependencyGraph relevant = new DependencyGraph(dependencyGraph.getRootNode());
        this.getRelevantHelper(relevant.getRootNode(), relevant, dependencyGraph);
        return relevant;
    }

    protected void getRelevantHelper(AbstractNode node, DependencyGraph relevant, DependencyGraph orig) {
        if (node instanceof NormalNode) {
            for (AbstractNode successor : orig.getSuccessors(node)) {
                // if this node has already been added to the relevant graph...
                if (relevant.containsNode(successor)) {
                    relevant.addEdge(node, successor);
                    continue;
                }

                relevant.addNode(successor);
                relevant.addEdge(node, successor);
                getRelevantHelper(successor, relevant, orig);
            }
        } else if (node instanceof BuiltinFunctionNode) {
            BuiltinFunctionNode builtinFunctionNode = (BuiltinFunctionNode) node;
            String opName = builtinFunctionNode.getName();
            // list for indices of multi-dependency functions
            List<Integer> multiList = new LinkedList<>();

            if (!builtinFunctionNode.isBuiltin()) {
                // call to function or method for which no definition
                // could be found
                AbstractCfgNode cfgNodeX = builtinFunctionNode.getCfgNode();
                if (cfgNodeX instanceof CallUnknownFunction) {
                    CallUnknownFunction callUnknown = (CallUnknownFunction) cfgNodeX;
                    if (callUnknown.isMethod()) {
                        AbstractNode sanitNode = new NormalNode(
                            new Literal("<method-call>"), builtinFunctionNode.getCfgNode());
                        relevant.addNode(sanitNode);
                        relevant.addEdge(builtinFunctionNode, sanitNode);
                    } else {
                        AbstractNode uninitNode = new UninitializedNode();
                        relevant.addNode(uninitNode);
                        relevant.addEdge(builtinFunctionNode, uninitNode);
                    }
                } else {
                    throw new RuntimeException("SNH");
                }
                // end of recursion

                // STRONG SANITIZATION FUNCTIONS ************************
            } else if (isStrongSanitation(opName)) {
                AbstractNode sanitNode = new NormalNode(
                    new Literal("<sanitization>"), builtinFunctionNode.getCfgNode());
                relevant.addNode(sanitNode);
                relevant.addEdge(builtinFunctionNode, sanitNode);
                // end of recursion

                // WEAK SANITIZATION FUNCTIONS ************************
            } else if (isWeakSanitation(opName, multiList)) {
                multiDependencyRelevant(builtinFunctionNode, relevant, orig, multiList, false);

                // EVIL FUNCTIONS ***************************************
            } else if (isEvil(opName)) {
                AbstractNode uninitNode = new UninitializedNode();
                relevant.addNode(uninitNode);
                relevant.addEdge(builtinFunctionNode, uninitNode);
                // end of recursion

                // MULTI-OR-DEPENDENCY **********************************

                // TODO: generic value flows should better be modeled during
                // depgraph construction, and not here
            } else if (isMultiDependencyOperation(opName, multiList)) {
                multiDependencyRelevant(builtinFunctionNode, relevant, orig, multiList, false);

                // INVERSE MULTI-OR-DEPENDENCY **************************
            } else if (isInverseMultiDependencyOperation(opName, multiList)) {
                multiDependencyRelevant(builtinFunctionNode, relevant, orig, multiList, true);

                // CATCH-ALL ********************************************
            } else {
                System.out.println("Unmodeled builtin function: " + opName);
                AbstractNode uninitNode = new UninitializedNode();
                relevant.addNode(uninitNode);
                relevant.addEdge(builtinFunctionNode, uninitNode);
                // end of recursion
            }
        } else if (node instanceof UninitializedNode) {
            // end of recursion: this is always a leaf node
        } else {
            throw new RuntimeException("SNH: " + node.getClass());
        }
    }

    /**
     * Helper function for multi-dependency builtin functions (in relevant subgraph construction).
     *
     * @param builtinFunctionNode
     * @param relevant
     * @param orig
     * @param indices
     * @param inverse
     */
    protected void multiDependencyRelevant(
        BuiltinFunctionNode builtinFunctionNode, DependencyGraph relevant, DependencyGraph orig, List<Integer> indices,
        boolean inverse
    ) {
        List<AbstractNode> successors = orig.getSuccessors(builtinFunctionNode);
        Set<Integer> indexSet = new HashSet<>(indices);

        int count = -1;
        boolean created = false;
        for (AbstractNode successor : successors) {
            count++;

            // check if there is a dependency on this successor
            if (inverse) {
                if (indexSet.contains(count)) {
                    continue;
                }
            } else {
                if (!indexSet.contains(count)) {
                    continue;
                }
            }

            created = true;

            if (relevant.containsNode(successor)) {
                relevant.addEdge(builtinFunctionNode, successor);
                continue;
            }
            relevant.addNode(successor);
            relevant.addEdge(builtinFunctionNode, successor);
            this.getRelevantHelper(successor, relevant, orig);
        }

        if (!created) {
            // if no successors have been created: make a harmless one
            AbstractNode sanitNode = new NormalNode(
                new Literal("<no-dep>"), builtinFunctionNode.getCfgNode());
            relevant.addNode(sanitNode);
            relevant.addEdge(builtinFunctionNode, sanitNode);
        }
    }

    /**
     * Finds those uninitialized nodes in the given *relevant* dependency graph that are dangerous.
     *
     * @param graph the graph to check for dangerous nodes
     *
     * @return
     */
    protected Map<UninitializedNode, InitialTaint> findDangerousUninitializedNodes(DependencyGraph graph) {
        Set<UninitializedNode> uninitializedNodes = graph.getUninitializedNodes();

        Map<UninitializedNode, InitialTaint> retMe = new HashMap<>();

        for (UninitializedNode uninitializedNode : uninitializedNodes) {
            Set<AbstractNode> predecessors = graph.getPredecessors(uninitializedNode);
            if (predecessors.size() != 1) {
                throw new RuntimeException("SNH");
            }
            AbstractNode predecessor = predecessors.iterator().next();
            if (predecessor instanceof NormalNode) {
                NormalNode preNormal = (NormalNode) predecessor;
                switch (this.getInitialTaintForPlace(preNormal.getPlace())) {
                    case ALWAYS:
                        retMe.put(uninitializedNode, InitialTaint.ALWAYS);
                        break;
                    case IF_REGISTER_GLOBALS:
                        retMe.put(uninitializedNode, InitialTaint.IF_REGISTER_GLOBALS);
                        break;
                    case NEVER:
                        // nothing to do here
                        break;
                    default:
                        throw new RuntimeException("SNH");
                }
            } else if (predecessor instanceof BuiltinFunctionNode) {
                // evil function, don't remove
                retMe.put(uninitializedNode, InitialTaint.ALWAYS);
            } else {
                throw new RuntimeException("SNH");
            }
        }

        return retMe;
    }

    protected List<NormalNode> findDangerousSources(DependencyGraph relevant) {
        List<NormalNode> retMe = new LinkedList<>();

        // get dangerous uninitialized nodes, and then inspect their predecessors
        Set<UninitializedNode> uninitializedNodes = this.findDangerousUninitializedNodes(relevant).keySet();
        for (UninitializedNode uninitializedNode : uninitializedNodes) {

            Set<AbstractNode> predecessors = relevant.getPredecessors(uninitializedNode);
            if (predecessors.size() != 1) {
                throw new RuntimeException("SNH");
            }
            AbstractNode predecessor = predecessors.iterator().next();
            if (predecessor instanceof NormalNode) {
                NormalNode preNormal = (NormalNode) predecessor;
                retMe.add(preNormal);
            } else if (predecessor instanceof BuiltinFunctionNode) {
                // evil function, ignore
            } else {
                throw new RuntimeException("SNH");
            }
        }

        return retMe;
    }
}